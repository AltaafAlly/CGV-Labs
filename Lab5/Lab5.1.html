<!DOCTYPE html>
<html>

<head>
    <title>Lab 5.1 Cube</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="webgl-canvas" width="500" height="500"></canvas>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
    <script type="text/javascript">

        const vertexShaderSource = `
            
        `;

        const fragmentShaderSource = `
            
        `;

        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            console.error('WebGL not supported, falling back on experimental-webgl');
            gl = canvas.getContext('experimental-webgl');
        }

        if (!gl) {
            alert('Your browser does not support WebGL');
        }

        // Define the vertices for a cube
        const vertices = new Float32Array([
            -1, -1, -1,
            1, -1, -1,
            -1, 1, -1,
            1, 1, -1,
            -1, -1, 1,
            1, -1, 1,
            -1, 1, 1,
            1, 1, 1,
        ]);

        // Define indices to form triangles
        const indices = new Uint16Array([
            0, 1, 2, 1, 2, 3, // Front face
            4, 5, 6, 5, 6, 7, // Back face
            0, 1, 4, 1, 4, 5, // Bottom face
            2, 3, 6, 3, 6, 7, // Top face
            0, 2, 4, 2, 4, 6, // Left face
            1, 3, 5, 3, 5, 7  // Right face
        ]);

        const colors = new Float32Array([
            // RGB color values for each vertex
            1, 0, 0, // Red
            0, 1, 0, // Green
            0, 0, 1, // Blue
            1, 1, 0, // Yellow
            0, 1, 1, // Cyan
            1, 0, 1, // Magenta
            0.5, 0.5, 0.5, // Gray
            1, 0.5, 0.5, // Light Red
        ]);

        // Enable depth testing
        gl.enable(gl.DEPTH_TEST);

        // Create buffer for vertices and indices
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);


        // Create buffer for colours
        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        // Define transformation matrices
        const modelMatrix = mat4.create(); // Model matrix (for object transformation)
        const projectionMatrix = mat4.create(); // Projection matrix (for perspective projection)

        // Set up transformation matrices (replace these values with actual transformation data)
        const translateX = 0.0;
        const translateY = 0.0;
        const translateZ = -5.0;
        mat4.translate(modelMatrix, modelMatrix, [translateX, translateY, translateZ]); // Translation

        const angleInRadians = 0.0;
        const axisX = 0.0;
        const axisY = 1.0;
        const axisZ = 0.0;
        mat4.rotate(modelMatrix, modelMatrix, angleInRadians, [axisX, axisY, axisZ]); // Rotation

        const scaleX = 1.0;
        const scaleY = 1.0;
        const scaleZ = 1.0;
        mat4.scale(modelMatrix, modelMatrix, [scaleX, scaleY, scaleZ]); // Scaling

        const fieldOfViewRadians = Math.PI / 4; // 45 degrees
        const aspectRatio = canvas.width / canvas.height;
        const nearPlane = 0.1;
        const farPlane = 100.0;
        mat4.perspective(projectionMatrix, fieldOfViewRadians, aspectRatio, nearPlane, farPlane);

        // Define shader program (createProgram function should be defined)
        const shaderProgram = createProgram(gl, vertexShaderSource, fragmentShaderSource);

        // Get attribute and uniform locations
        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        const colorAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_color');
        const modelMatrixUniformLocation = gl.getUniformLocation(shaderProgram, 'u_modelMatrix');
        const projectionMatrixUniformLocation = gl.getUniformLocation(shaderProgram, 'u_projectionMatrix');

        // Set up the WebGL context
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(shaderProgram);

        // Bind position buffer and set attributes

        // Bind color buffer and set attributes

        // Set uniform values for matrices (model and projection)

        // Draw the cube using gl.drawElements
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);




        function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
            let vsh = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vsh, vertexShaderSource);
            gl.compileShader(vsh);
            if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {
                throw new Error("Error in vertex shader:  " + gl.getShaderInfoLog(vsh));
            }
            let fsh = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fsh, fragmentShaderSource);
            gl.compileShader(fsh);
            if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {
                throw new Error("Error in fragment shader:  " + gl.getShaderInfoLog(fsh));
            }
            let prog = gl.createProgram();
            gl.attachShader(prog, vsh);
            gl.attachShader(prog, fsh);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                throw new Error("Link error in program:  " + gl.getProgramInfoLog(prog));
            }
            return prog;
        }

        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
    </script>
</body>

</html>